use std::hint;

use reqwest::blocking::Response;
use reqwest::StatusCode;

use crate::request::*;
use crate::payloads::*;

/// Struct that represents a simplified Response
#[derive(Debug)]
pub struct SimpleResponse {
    pub status: StatusCode,
    pub headers: reqwest::header::HeaderMap,
    pub body: String,
}

/// Function that transforms a Response into a simpleResponse
/// Arguments:
/// - response: the response to transform
/// Returns:
/// - simpleResponse
pub fn simplify_response(response: Response) -> SimpleResponse {
    let status = response.status();
    let headers = response.headers().clone();
    let body = response.text().expect("could not read response body");
    SimpleResponse {
        status,
        headers,
        body,
    }
}


/// Function that compares the response of a form with a sample
/// to detect if the form is vulnerable to sql injection
/// Arguments:
/// - sample: the sample response
/// - response: the response to compare
pub fn compare_request(sample: &SimpleResponse, response: &SimpleResponse) -> i32 {
    let mut hint_sqli = 0;
    // put emojis to make the output more readable
    // compare the status code
    if sample.status != response.status {
        hint_sqli += 1;
        // put emojis to make the output more readable
        // if the status code is different
        println!("ğŸ”€ The status code is different");
        println!("Sample: {}", sample.status);
        println!("Response: {}", response.status);
    }
    // compare the headers
    // and print the differences
    for (header, value) in sample.headers.iter() {
        if response.headers.get(header) != Some(value) {
            if header == "Set-Cookie" || header == "Date" || header == "Content-Length" {
                continue;
            }
            hint_sqli += 1;
            println!("ğŸ”€ The header {} is different", header);
            println!("Sample: {}", value.to_str().unwrap());
            println!("Response: {}", response.headers.get(header).unwrap().to_str().unwrap());
        }
    }
    // compare the body of the response
    // and print the differences
    // line by line
    if response.body != sample.body {
        let mut diff_response = String::new();
        println!("ğŸ”€ The body is different");
        let sample_lines: Vec<&str> = sample.body.lines().collect();
        let response_lines: Vec<&str> = response.body.lines().collect();
        for (i, line) in response_lines.iter().enumerate() {
            let next_line = sample_lines.get(i);
            if next_line.is_none() {
                diff_response.push_str(line);
                continue;
            }
            if line != next_line.unwrap() {
                hint_sqli += 1;
                diff_response.push_str(line);
            }
        }
        // diff_response to lowercase
        let diff_response = diff_response.to_lowercase();
        // look for keywords in the response
        for keyword in KEYWORDS_DETECTION {
            if diff_response.contains(keyword) {
                hint_sqli += 1;
                println!("ğŸª‡ The response contains the keyword: {}", keyword);
            }
        }
        // check if sample has more lines
        if sample_lines.len() > response_lines.len() {
            hint_sqli += 1;
            println!("â• Sample has more lines");
        }
    }
    // print the score with an emoji
    println!("ğŸ’¡ Score: {}", hint_sqli);
    hint_sqli
}

/// Function that create the url to submit a form
/// Arguments:
/// - url: the url of the form
/// - action: the action of the form
/// Returns:
/// - the url to submit the form
pub fn create_url(url: &String, action: &String) -> String {
    // remove get parameters from url
    let url = url.split("?").collect::<Vec<&str>>()[0];
    let base_url = url.split("/").collect::<Vec<&str>>();
    let base_url = base_url[0..3].join("/");
    if action.starts_with("http") {
        action.to_string()
    } else if action.starts_with("/") {
        format!("{}{}", base_url, action)
    } else {
        // if action starts with ./, remove it
        let action = if action.starts_with("./") {
            action.split_at(2).1
        } else {
            action
        };
        if url.ends_with("/") {
            format!("{}{}", url, action)
        } else {
            format!("{}/{}", url, action)
        }
    }
}


/// Function to use payloads to test a form
/// This function fills the form with payloads
/// and sends the form via a get or post request
/// Arguments:
/// - url: the url of the form
/// - form: the form data
pub fn test_form(url: &String, form: &FormData, sample: Response) -> bool {
    let sample = simplify_response(sample);
    let mut hint_sqli = 0;
    for payload in DETECTIONS {
        // print the payload with emojis
        println!("\n              ğŸ” Testing payload: {}", payload);
        let mut body = String::new();
        for param in &form.params {
            body.push_str(&param);
            body.push_str("=sample");
            body.push_str(&payload);
            body.push_str("&");
        }
        body.pop();
        let response: Response;
        let url = form.url.clone();
        if form.method == "post" {
            let content_type = "application/x-www-form-urlencoded";
            response = post(&url, &body, &content_type.to_string()).expect("get request failed");
        } else {
            response = get(&url).expect("get request failed");
        }
        let response = simplify_response(response);
        hint_sqli += compare_request(&sample, &response);
    }
    if hint_sqli < 5  {
        println!("âœ… The form is not vulnerable to SQL injection");
        true
    } else {
        println!("ğŸš¨ The form is probably vulnerable to SQL injection");
        false
    }
}

/// Function to have a sample of a normal response for a form
/// This function fills the form with default values
/// and sends the form via a get or post request
/// Arguments:
/// - url: the url of the form
/// - form: the form data
pub fn sample_form(url: &String, form: &FormData) -> Response {
    let mut body = String::new();
    for param in &form.params {
        body.push_str(&param);
        body.push_str("=sample&");
    }
    body.pop();
    if form.method == "post" {
        let content_type = "application/x-www-form-urlencoded";
        let response = post(&url, &body, &content_type.to_string()).expect("get request failed");
        response
    } else {
        // check if the url finish with a / or not
        let url = if url.ends_with("/") {
            format!("{}?{}", url, body)
        } else {
            format!("{}/?{}", url, body)
        };
        let response = get(&url).expect("get request failed");
        response
    }
}